{{define "page"}}
<h1>Report</h1>
<h2>What is target rifle shooting?</h2>
<h2>Brief history of Victorian Target Rifle Shooting</h2>
	VRA formed in 1860's
	Williamstown closed in 1992
	Stawell Rifle Club lengthened their range in 2003
		they now to Match rifle shooters and sometimes recieve shooters internationally
	Competitor numbers have slowly been dwindling for many years
<h2>What is a target Rifle competition like?</h2>
Overwhelming and Stressful for beginners traveling to a new range by themselves
Takes a long time to start heading home

<h2>What where some points that were not expected?</h2>
Uncovered cheating in the 2013 Victorian champion of champions team match. Refused to organise scores for the following year. Scores where modified on paper compared to shots fired. I tried to fix the mess and retrieve the correct scores, but after 45 minutes I gave up. EB scoreboard was thrown out and incorrect cores where beemed correct.
No work was done on EB for the following 6 months and I also withdrew from shooting.

<h2>competitors systems?</h2>


<h2>Interview questions for EventBucket Opinion.</h2>
what was good about eventbucket<br>
what was bad about eventbucket<br>
No one was ever interested in useing EB. Why do you think that was?<br>
how could EB be changed to appeal to a wider ausience?<br>
do you think EB made Prize Meetings better? - more organised?<br>
do you think Cam communicated poorly and no no one ever knew what was going on?<br>
Did EB ever perform poorly?<br>

<h2>Interviewees?</h2>
<ul>
	<li>Mick</li>
	<li>Cara</li>
	<li>Pete</li>
	<li>Leo Stigger</li>
</ul>

<h2>What didn't work well</h2>
<ul>
	<li>ace HTML templating. biggest problem was adding spaces between elements was awkward. No syntax hilighting. sometimes file extension would open in a zip extraction program when editing files not on my normal developer workstation.</li>
	<li>Second monitor failed three times.</li>
	<li>IntelliJ IDEA
		<ul>
			<li>Displays false positives with golang syntax errors and unresolved variables</li>
			<li>External file changes are not supported. Files fixed by build bot are not auto updated</li>
			<li>Editor is slow</li>
			<li>when network drive is disconnected constant java error popups and unable to refresh project to see files again.</li>
			<li></li>
		</ul>
	</li>
	<li>grunt build tools. lots of configuration - time consuming for not much gain</li>
	<li>gulp build tools. waisted time with trying out plugins that don't work, debugging etc. others have had similar experience. errors are not handled properly or are poor/error prone to crashes for some plugins. Difficult to decipher poor documentation.</li>
</ul>
<h2>What worked</h2>
<ul>
	<li>Build bot can fix common Golang programming mistakes. Just run the executable in a directory. no need to setup an IDE and programming environment.</li>
	<li>Git - helps keep track of changes. Some that are not good enough for product can be rolled back. Backup</li>
	<li>Buildbot runs on an old networked laptop. off loads processing. Best for external monitor</li>
	<li>build EB on slower hardware that the target audience has. reduces problems with intensive CPU tasks by discovering them earlier.</li>
	<li>run BuildBot and EB in CompileDeamon so they auto recompile whenever code is changed in their files</li>
</ul>

<pre>
EventBucket Mission Statement:
Build the simplest website possible
Only add frameworks/packages where it will safe significant time/resources.
Target audience: "outback" Australia with limited internet connection & speed (if available)
Before the National Broadband Network scheme north western Victoria farms had available
poor ADSL - 100km from the closest node no ADSL2+ 35% packet loss
satelite - running at 150% capacity. Peek periods averaged 1.76KB/s download
3G wifi - not available - next door neibour erected a 4m tall arial ~ 40+dB - erratic connectivity in windy, super hot(mirages) rain, stormy weather, lighting,
dialup - two phone lines required - billed on time rather than traffic.
Serve each file within 1KB gzipped - 1 second download time.
removed internet connection requirement and went with local connection

Offline website was considered
a mesh like network would be hard to maintain information in, on a javascript front end environment.
node js wasn't abot to be compiled and 3rd party code was difficult to use in 2013.
callback nightmare
early days for the offline website technology.
indexedDB was suited and scored could be saved to browser easily and transfered to server once finished.
difficult to determine status of shoot from the server point of view. Has the scores for shooter X been recorded or missed.
many nodes of failure instead of a single node of failure. - battery life & needing to retrieve scores.
the first iPad had poor javascript performance & wasn't suitable. the page needed to be simplified significantly.

Javascript
CoffeeScript
The idea of simplifying Javascript and writing less code to do more is a good one. However I disagree on a few of the default behavior implementations.
functions return the last written. Often handy but also a pain if you have to write return undefined everywhere

the amount of javascript code it generates is more than hand coded javascript.

code can be confusing/difficult to read without parenthesis

It doesn't assist with dynamic typing

more complex & slower build server

jQuery
When EventBucket was first prototyped in 2012, jquery was a 81KB minified download. That was 76KB larger than the rest of the home page combined.
Often when jquery seemed handy to use I knew I was doing something wrong or too complicated & it could be written better.

favicon
it would be nice if browsers supported svg favicons. It would save having to specify different images & multiple sizes for each device.
Firefox has started supporting svg but chrome still fall behind.

combine resources
IE supports combining javascript & css into the same file by wrapping each in html and javascript comment tags.
at best it
downloaded the file once for CSS and was cached never to ask again
ask for the file again
and the server at best could respond with NOT MODIFIED.

Chrome didn't support the odd parsing.
chrome instead supports spdy which I never got running and didn't really need it in golang
Firefox did support but the server must respond with a complete new file. NOT MODIFIED didn't work.

HTML optimisation:
replace html tags with sorter ones &lt;input =&gt; &lt;x, &lt;h1 =&gt; &lt;h, etc.
worked with browsers although additional css needed to be downloaded.
render time was slightly slower since the CSS needed to be ungzipped, parsed and applied.
an extra round trip time was needed to retrieve the css. - although CSS would be needed any way the page would be completely unusable if CSS wasn't downloaded.

SVG sprite reuse
one svg file - many objects. apply one class to get the object you need.
insert svg within CSS without base64 - but needed the setup costs of svg element, viewbox etc
make svg external and larger - makes css appear faster to render
icons are slower to appear.
one one request for an svg and you have them all

javascript to insert just the object you needed was extra cost for no real benifit except making the code look nicer. slightly less browser resource consumption for hiding unused svgs.
reduced the amount of svgs used and the javascript became completly redundant for less than 3-7 objects??

No javascript on home page.
unable to add helpful things like textarea Ctrl + Enter shortcuts. single page app, browser html caching
browser html caching isn't really needed as most pages require a fresh view on most visits and would be come more complex to distinguish between needing to update local browser cache and using the existing cache. what if user didn't recieve notification that update was needed and they wern't able to update page anymore.
Keep It Simple Stupid.


Programing methodologies:
KISS - lockheed martin
no code, no bugs - Andrew & Ash @ Smalldog Design.


Internationalisation:
why wasn't this done. Lack of TIME!!
github.com/nicksnyder/go-i18n is a good package to translate and has support from pulrals.
but it doesn't have support for ordinals (1st, 2nd, 3rd, ...) at the first time of investigation as at Oct 2015.
seems time consuming to create key value pairs. would prefer django style where translator translates the actual text.










Code style:
I tried to use Golang code style for Javascript but it didn't go so well.

Instead of if else, used if !not, return.

Positives
found that the main code was easier to read. most used code was all on the same indentation.

Negatives:
Harder to where a function is returned as errors are indented
There is more than one return for each function.
lots of negation used to return function early. Not using simple if err != nil. but change
xhr.status === 200 && xhr.readyState === 4 ){
to
xhr.status !== 200 || xhr.readyState !== 4) retrun;




Reducing network traffic:
Returning html response after a POST consists of mostly html characters and less "information"

Expermented with pure.js and transparency.js.
Problems:
Parsing the html rather than simply adding the values to the template html
Pure.js has a key/value pair and a directive/selector pair to maintain.
Have to maintain a normal request response and a "optimised" response chain. If returning only "optimised" templating then the page won't work without Javascript enabled.
Javascript is disabled on 1% of browsers.
extra JS complexity and download added to the project for ajax/websocket endpoints. - How much browsing would be required to overcome the initial boilerplate load?
Would need additional backend code to generate the key/value pairs.
Browser would utilise more memory to execute extra javascript code.
Introducing more points of failure in the app.
Longer time needed to test in different browsers.
One more request will be required to load the page. HTML + CSS + JS. + JSON
Adding a dynamic JSON minifyer + gzip to the chain would make the response slightly slower to generte.
Templating invalid forms from back end would be more complex to toggle error messages.
Complex to cahce html template response but not the full html generated with data.
Slower to develop, more code to maintain
http://www.workingsoftware.com.au/page/Your_templating_engine_sucks_and_everything_you_have_ever_written_is_spaghetti_code_yes_you


Positives:
Traffic (after inital load) is smaller and faster to transfer across a very slow network connection.
Extremely responsive/snappy experience loading/updating existing tables that are already loaded. Potential to load/alter only rows that have been added, updated or deleted
HTML templtes could be cached for 1 year. the JSON response changes instead.
Seems like the current trendy thing to do. Traditional response with limited or no javascript is becoming rarer.



Above scenario is a modern take on parsing the old xhtml and XSLT with xml data. At least the browser would translate the data into XHTML. However XSLT was very complex and that flexible.



datalists:
there is inconsistant implementations for the datalist element.
Chrome & Opera show the option value & label
Firefox & IE 11 show only the option label
http://stackoverflow.com/questions/29882361/show-datalist-labels-but-submit-the-actual-value

how can this be fixed?
simple: don't use id in this case and only provide Label.
use Label in the backend as an additional case insensitive unique identifier, but also have an id
return label as normal
</pre>

<h3>Mongodb issues</h3>
<p>I am not using javascript scripting in mongodb selects and updates. this puts more pressure on the database with increased quantity of queries on the database but also<br>
the queries don't run atomically (in parallel) so there is a higher risk of wrong ids and it is just overall slower that way.</p>
<p>Would like to move to mobile crouchbase database. so that syncing in future could be much simpler. Couchbase also has a larger document limit of 20MB, compared to 16MB for MongoDB</p>
<p>thought that not writing mongodb scripting would help the program to be less database agnostic. This is true is some cases - no stored procedures need to be written in sql if moved to a RDBMS. However it requires auto increment code in the program.</p>
<p>mongodb isn't a silver bullet. Putting all event data in a single object will eventually lead to a document overflow where no more data can be stored within the object because it has exceeded 16MB</p>
<pre>
sql schema compare:        mongodb
read - painful             enjoyable
write - easy               more complex
joins - doable             teadious
</pre>

<h2>Form generation</h2>
why I didn't use struct validation
	lots of casting interfaces to struct type
	form fields don't always reflect structs.
		club search fields return club name as a string instead of club id
	limited support for different types. - this is now more fully implemented


manually write form html
	write validation code for each form
	validation often missmatched
	html was inconsistant. change one form layout and that had to be applied to all forms
		wrote a fieldset wrapper to help with the startup cost of writting a form. <code><form><fieldset><legend></legend></code>

	quick form generation

one struct type for all form fields
	validate values was still - manually create maps
	code lived on the server and generated a new form every page load - no caching
	+ populating forms with fields was really easy
	- page load speed is slow
	- pages are prown to xss attacks because generating html using fmt :( - acuntics 9 demo
	- unable to create a form with two different actions - shooter entry on event page

one struct type for each kind of form field
	+++ moved validation code isValid into http post wrapper so it is done automatically
	-- "duplicate" struct for each form field in the list of forms to validate against
	- populating fields with default values is harder than previous
	- changing a form field order now breaks pages referencing fields by index insted of old map[string]
	+ validation is now a lot easier
	+ duel form actions supported
	+ page load is much more snappier
	+ form html is completly generated by form builder
	- no form customizeablity for a single form - would have to manually write form code.
	+ modify layout of forms affects all others and is really fast to generate
	+ swaping fields around in html doesn't require a server to restart now.
	+ can save fields to a variable to reuse

<h1>Bolt DB</h1>
trialing boltDB. reduced compiled size
EventBucket with MongoDB size: 9.46 MB (9,927,680 bytes)
EventBucket with Bolt DB size: 8.86 MB (9,300,480 bytes)


{{end}}